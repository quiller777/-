Task02
# 基于Python的线性代数实现
## 1.线性方程组与向量
> - 线性方程组可以看成一张表格，其中通过不同系数进行对应关系的标识
> - 每个变量系数可以看成一个向量，多个向量从而组成方程组的矩阵
> - 系数矩阵常用 **“A”**  标识，结果向量也称为常数向量，通常记为 **“b”**

> 可以通过numpy库进行方程组求解
> **import numpy as np**
> **A = np.array([[1, 1],   [2, 4]])**    # 将系数所有向量拼在一起
> **b = np.array([10, 28])** 			   # 常数向量
> **x = np.linalg.solve(A,b)** 			 # 解线性方程组
> **print("线性方程组的解为：\n",x)**
>
>  **numpy.linalg.solve(a, b)**			# 以矩阵形式解线性矩阵方程
>  a为系数矩阵，b为纵坐标货因变量的值（y)

## 2.向量空间、矩阵、行列式及范数
> 在实际求解中，会遇到一系列问题，导致无法计算：
> - 要求系数矩阵是方阵，即有多少个未知数，就需要有多少个方程
> - 系数矩阵奇异(**Singlar Matrix** ),即存在等式信息已被其它等式涵盖，对实际求解起不到任何作用

> 需要解决的目标问题为：
> - 当求解n个未知数时，方程组有解需要满足的条件？
	***n个未知数要有n个方程***
	***通过线性无关判断"有效"方程*** ---> **系数行列式|A|不等于0，则方程组有唯一解**
> - 向量推广到高维，向量间计算如何满足？
	***只要高维向量是有限维的，都满足加法与数乘的运算法则***

### 2.1 向量的运算法则
> 1. 向量的加法定义: 	向量间对应分量相加
> 2. 向量的数乘定义:	每个分量都乘上k
> 
> 注:为了书写直观，为了将列向量转化为行向量标识，引入向量的转置，记为 **x^T**

>适用numpy进行向量间基本计算
> **format(x.shape)**		# 显示向量维度
> **format(x+y)**
> **format(k*x)**
>  **format(3*x+2*y)**

### 2.2 向量的线性相关与无关
> 如果某向量能被另外一个向量组进行表示，即线性相关，存在奇异性
> 
> 为了简化有效性（线性无关）判断，引入行列式概念
>  - 对于行数等于列数的方阵才能计算行列式 **|A|**
      通过Numpy进行计算：
	  **np.linalg.det(A)**          #计算方阵A的行列式
	  
> **克林姆法则**
> 通过如下条件判断方程组是否有解？
>  - 未知数个数等于方程个数
>  - 系数行列式|A|不等于0，则方程组有唯一解
>  - Xn= det(Dn)/det(D)     
		det(Dn)计算是用b取代a1n那列

> 行列式的物理意义
> 以二阶行列式为例，其由2个2维向量组成，行列式的结果为2个向量为临边的平行四边形面积

### 2.3 矩阵
> **矩阵的运算法则**
> - 以矩阵A为例，若行数为n，列数为m,则矩阵维度为n*m
> - 两个矩阵乘法时，如Aa*b Bc*d，若A*B有意义，则b=c,相乘后结果维度为a*d 
	(不能随便交换顺序，即A*B不一定等于B*A)
> 通过Numpy进行矩阵计算
>  **np.matmul(A,B))**
>  - 两个维度大小一样的矩阵可以做加法，结果等于相应位置元素相加
>  - 矩阵乘以常数等于每个位置元素都乘以这个常数
>  - 行变化 ---> 左乘； 列变换 --->右乘

> **特殊矩阵**
> 1. 单位矩阵
		从左上角到右下角的对角线上元素均为1的方阵，除此以外全都为0
		如同数乘中1的作用，矩阵A*单位矩阵 = 矩阵A
		**np.eye(3)**		# 3阶单位矩阵（生成对角阵）
		
> 2. 初等矩阵
> 	 - 交换原始矩阵的行或列
		交换行左乘P；交换列右乘P； 
		P为左下角到右上交的辅对角线上元素均为1的方阵，除此之外全部为0
		
>3. 逆矩阵
> 		对n阶方阵A，若存在一个n阶方阵B，使得A*B = B*A = E （E为n阶方阵）
		则称A可逆，B为A的逆矩阵，记作 **A^(-1)**
>	
>	 **A为非奇异矩阵时可逆**
	- 是方阵（行数=列数）
	- 行列式不等于0
>	  	
> 		通过Numpy进行逆矩阵计算
 **np.linalgdet(A)**	#先检验是否奇异，是否满足可逆
**np.linalg.inv(A)**	# 求逆矩阵

> 4.  逆伪
> 对于n*m维度矩阵A，存在m*n维度矩阵A^g,使得A*(A^g)*A = A,
则称A^g为A的伪逆 （广义逆）
> 		通过Numpy进行伪逆计算
**np.linalg.pinv(A)**	# 求广义逆矩阵
**np.matmul(A,np.linalg.pinv(A),A))**		# 对广义逆进行验证

> 5. 相似矩阵	
> 		A= (P^-1) * B * P ---> A与B为相似矩阵

> 6. 对角矩阵 /特征值/特征向量
>  若Λ为对角矩阵，  (P^-1) * A * P = Λ ,则A的特征值与Λ一致
	Ax= Λx
> 	通过Numpy进行特征值和特征向量计算
> 	**lamb,p = np.linalg.eig（A)**			
	#	计算矩阵A的特征值和特征向量，返回特征值lamb,特征向量p
> **res = np.matmul( np.linalg.inv(p), np.matmul(A,p) )**
	# 矩阵A对角化 （特征值分别在主对角线上，其余位置为0）
> **res[np.abs(res)<1e-6] = 0**		
	# 将绝对值小于10的-6次方的值化为0 （数值过滤）
> 		
> 		tips:特征向量可以使矩阵变化后保持在同一直线上

> 7. 正交矩阵
>  使向量进行旋转或者镜像变换的矩阵
	(A^T) * A = A* (A^T) = I， 则A为正交矩阵
> - 因为A^(-1) * A = I , 所以正交矩阵的逆矩阵与转置矩阵相同：A^(-1) = (A^T),
> - A的各行是单位向量且两两正交（垂直）			**𝛼𝑖⋅𝛼𝑇𝑖=1 ，也就是说𝛼𝑖是单位向**
	又或者说A的各列是单位向量且两两正交（垂直）	**𝛼𝑖⋅𝛼𝑇𝑗=0(𝑖≠𝑗) ，向量之间两两正交**
> - 最简单的正交矩阵是单位矩阵
> 
> 	**施密特正交化**
> 	**from scipy.linalg import***	
	**B = orth(A)**  # 返回A的正交基
	**res = np.matmul( B, np.transpose(B) )**   # 输出正交矩阵
